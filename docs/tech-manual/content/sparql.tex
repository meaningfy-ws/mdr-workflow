\section{SPARQL Queries}

\subsection{Naming conventions}
\subsubsection{Operations}

Looking at patterns of change likely to occur in the context of maintaining SKOS vocabularies or to find in a diffing context we've identified 5 change types and mapped them for easy referencing as follows:

\begin{itemize}
  \item Addition $\rightarrow$ Added
  \item Deletion $\rightarrow$ Deleted
  \item Value update $\rightarrow$ Updated
  \item Movement (cross property) $\rightarrow$ Changed
  \item Movement (cross instance) $\rightarrow$ Moved
\end{itemize}

\subsubsection{Query file name}

In order to name a query file that will represent what is the query for ,but in the same time to be easy to read, the file name will be constructed from five parts. These are operation, rdf type, class name, property name and object property name. All names are only the local segment of the Qname (compressed URI) provided and the rdf types are instance, property and reified (reified property).

File name examples:

Structure $\rightarrow$ \texttt{operation\_rdfType\_className}

File name: added\_instance\_collection

Structure $\rightarrow$ \texttt{operation\_rdfType\_className\_propertyName}

File name: changed\_property\_concept\_broader

\subsection{Structure}
In this project the SPARQL query is constructed from five parts that will be explained below.

\subsubsection{Prefixes section}
Prefixes section are declared in here before the select statement of the query. It can have as many possible prefixes and values as the query will use only the ones that it needs.

\subsubsection{Query variables}
A SPARQL query file could sometimes be long and hard to read. To improve readability and minimize use of hidden variables, the query parameters should express in some manner what is the query used for and also to have the same values in the entire query. For easy referencing a change from the SPARQL query parameters, a good option is to add a prefix to the parameters that will have the value changed in the diffing context. To avoid pollutions of variables names the convention will add prefix in front of the variables that is changing in the diffing context by using the query. This can only be old or new (i.e ?oldInstance ?newInstance).

\subsubsection{Version history graph block}
This block will remain unchanged for all diffing queries as it's defining the graphs that are used later in the query. As a mention there is only one part that can change here and that is the value injection for the query which will be present in the next section. The logic of the query is based on this four graphs that are built here. We can see below that we are going to have access to newVersionGraph, oldVersionGraph, insertionsGraph and deletionsGraph, so we can filter our data.

\begin{lstlisting}
GRAPH ?versionHistoryGraph {

  # parameters
  VALUES ( ?versionHistoryGraph ?oldVersion ?newVersion ?class) {
      ( undef 
        undef 
        undef  
        skos:Concept 
      )
  }
  # get the current and the previous version as default versions
  ?versionset dsv:currentVersionRecord/xhv:prev/dc:identifier ?previousVersion .
  ?versionset dsv:currentVersionRecord/dc:identifier ?latestVersion .
  # select the versions to actually use
  BIND(coalesce(?oldVersion, ?previousVersion) AS ?oldVersionSelected)
  BIND(coalesce(?newVersion, ?latestVersion) AS ?newVersionSelected)
  # get the delta and via that the relevant graphs
  ?delta a sh:SchemeDelta ;
    sh:deltaFrom/dc:identifier ?oldVersionSelected ;
    sh:deltaTo/dc:identifier ?newVersionSelected ;
    sh:deltaFrom/sh:usingNamedGraph/sd:name ?oldVersionGraph ;
    sh:deltaTo/sh:usingNamedGraph/sd:name ?newVersionGraph .
  ?insertions a sh:SchemeDeltaInsertions ;
    dct:isPartOf ?delta ;
    sh:usingNamedGraph/sd:name ?insertionsGraph .
  ?deletions a sh:SchemeDeltaDeletions ;
    dct:isPartOf ?delta ;
    sh:usingNamedGraph/sd:name ?deletionsGraph .
}
\end{lstlisting}

\subsubsection{Value injection}
As mentioned in the previous section there is a value injection block where we can assign values to variables that are going to be used in the query logic.

\begin{lstlisting}
# parameters
VALUES ( ?versionHistoryGraph ?oldVersion ?newVersion ?class) {
    ( undef 
      undef 
      undef  
      skos:Concept 
    )
}
\end{lstlisting}

\subsubsection{Query logic}
This part of the query is filtering the data by looking for triples in the graphs made available in the version history graph block. The graphs are made available through the delta generated (see \hyperlink{https://github.com/jneubert/skos-history/wiki/Versions-and-Deltas-as-Named-Graphs}{Versions and Deltas as Named Graphs}) by the diffing process, and they are as follows:

\begin{itemize}
  \item oldVersionGraph - contains triples existing in the old version file
  \item newVersionGraph - contains triples existing in the new version file
  \item insertionsGraph - contains added triples to the old version file
  \item deletionsGraph - contains triples deleted from the old version file
\end{itemize}

As an example, will want to look for new instances that are of a certain class and to achieve this will want to look into the insertions graph.

\begin{lstlisting}
GRAPH ?insertionsGraph {
  ?instance a ?class .

  optional {
    ?instance skos:prefLabel ?prefLabelEn .
    FILTER (lang(?prefLabelEn) = "en")
  }
}
\end{lstlisting}

The query logic can continue to filter the results by verifying existence of triples in other available graphs. This can be done by using another graph block as showed below.

\begin{lstlisting}
# ... and the instance must not exist in the old version
FILTER NOT EXISTS {
  GRAPH ?oldVersionGraph {
    ?instance ?p [] .
  }
}
\end{lstlisting}

\subsection{Example of diffing query}
Building a query to get all added skos:altLabel property per instance of a certain class.

\subsubsection{Prefixes section}

\begin{lstlisting}
# basic namespaces
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
.
.
.
# versioning namespaces
PREFIX dsv: <http://purl.org/iso25964/DataSet/Versioning#>
PREFIX sd: <http://www.w3.org/ns/sparql-service-description#>
PREFIX sh: <http://purl.org/skos-history/>
PREFIX xhv: <http://www.w3.org/1999/xhtml/vocab#>
\end{lstlisting}

\subsubsection{Query variables}
For the results and the query itself to be easy to read we need to choose good variable names and make sure the variables will bring the expected result format. In this case we want to see instance URI, instance label, property and value of the property.

\begin{lstlisting}
SELECT DISTINCT ?instance ?prefLabel ?property ?value 
WHERE {
\end{lstlisting}

\subsubsection{Version history graph block and value injection}
For the results and the query itself to be easy to read we need to choose good variable names and make sure the variables will bring the expected result format. In this case we want to see instance URI, instance label, property and value of the property.

\begin{lstlisting}
GRAPH ?versionHistoryGraph {
  # defining values for our variables that are we going to use in the query (instance class and property)
  VALUES ( ?versionHistoryGraph ?oldVersion ?newVersion ?class ?property) {
    ( undef
      undef
      undef
      skos:Concept 
      skos:altLabel 
    )
  }
  # get the current and the previous version as default versions
  ?versionset dsv:currentVersionRecord/xhv:prev/dc:identifier ?previousVersion .
  ?versionset dsv:currentVersionRecord/dc:identifier ?latestVersion .
  # select the versions to actually use
  BIND(coalesce(?oldVersion, ?previousVersion) AS ?oldVersionSelected)
  BIND(coalesce(?newVersion, ?latestVersion) AS ?newVersionSelected)
  # get the delta and via that the relevant graphs
  ?delta a sh:SchemeDelta ;
    sh:deltaFrom/dc:identifier ?oldVersionSelected ;
    sh:deltaTo/dc:identifier ?newVersionSelected ;
    sh:deltaFrom/sh:usingNamedGraph/sd:name ?oldVersionGraph ;
    sh:deltaTo/sh:usingNamedGraph/sd:name ?newVersionGraph ;
    dct:hasPart ?insertions ;
    dct:hasPart ?deletions .
  ?deletions a sh:SchemeDeltaDeletions ;
    sh:usingNamedGraph/sd:name ?deletionsGraph .
  ?insertions a sh:SchemeDeltaInsertions ;
    sh:usingNamedGraph/sd:name ?insertionsGraph .
}
\end{lstlisting}

\subsubsection{Query logic}
In this part we need to filter the results to get only the instances that had the skos:altLabel property added. As a starting point we will look in the insertions graph to get all inserted skos:altLabel properties for all instances. For this to be a true addition and not a change or a movement operation we need to make sure that the property was not attached to some other instance before and to do this will look into the deletions graph and old version graph. After filtering the result we can get all the values that are needed from the new version graph.

\begin{lstlisting}
# get inserted properties for instances
GRAPH ?insertionsGraph {
    ?instance ?property [] .
  }
  # ... which were not attached to some (other) instance before
  FILTER NOT EXISTS {
    GRAPH ?deletionsGraph {
      ?instance ?property [] .
    }
  }
  FILTER NOT EXISTS {
    GRAPH ?oldVersionGraph {
      [] ?property ?value .
    }
  }
  # get instances with those property values
  GRAPH ?newVersionGraph {
    ?instance a ?class .
    ?instance ?property ?value .

    optional {
      ?instance skos:prefLabel ?prefLabel .
      FILTER (lang(?prefLabelEn) = "en")
    }
  }
}
\end{lstlisting}
